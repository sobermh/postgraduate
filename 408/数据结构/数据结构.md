# 查找
## 线性查找
### 顺序查找
按照某种顺序依次遍历线性表中的每一个元素进行查找
平均查找成功次数：（n+1）/2
平均查找失败次数：n
### 折半查找
利用待查找序列的有序性，一次找到一半不存在答案的带查找区间
最多比较次数：log2（n），n不是2的整数幂，否则加1
折半查找判定树:
![](./asset/1656932977119.jpg)
平均查找成功次数：（1+1*2+3*4）/7
平均查找失败次数：（3*8）/8
是否是折半查找判定树：
![](./asset/1656933638065.jpg)
### 分块查找
同一块待查找序列可以无序，所有区块之间有序（不绝对）
平均查找成功次数(顺序查找)：
![](./asset/1656934489164.jpg)
## 树形查找
二叉查找树：左大右小；或左小右大。
### 平衡二叉树（AVL）:
1.二叉树->二叉排序树(BST)->平衡二叉树(AVL树)--》2.平衡二叉树满足二叉排序树的性质，即左小右大（或左大右小）--》3.某结点的平衡因子=左子树的高度-右子树的高度--》4.AVL树中所有结点的平衡因子只能为-1、0、1三者之一（左子树与右子树的高度差的绝对值小于等于1）。
![](./asset/1656935809838.jpg)
最少结点的AVL树：
f(n)=f(n-1)+f(n-2)+1
![](./asset/1656936225308.jpg)
#### AVL树的左旋操作
![](./asset/1656936362474.jpg)
#### AVL树的右旋操作
![](./asset/1656936421061.jpg)
#### AVL树的插入
1.将新元素按照二叉查找树的规则进行插入--》2.插入后自下而上进行平衡性的调整--》3.每次调整，调整的是“最小不平衡树”（最下面不平衡的结点）--》4.左子树的左子树导致不平衡->LL型对自身右旋调整--》5.左子树的右子树导致不平衡->LR型先对左子树左旋，再对自身右旋--》6.右子树的右子树导致不平衡->RR型对自身左旋调整--》7.右子树的左子树导致不平衡->RL型先对右子树右旋，再对自身左旋。
#### AVL树的删除
1.将新元素按照二叉查找树的规则进行删除--》2.更具体的，若删除的元素是叶子结点，则直接删除--》3.若删除的元素是非叶子结点，先与前驱或后继结点交换，再进行删除--》4.前驱结点：该结点左端部分最右边下边的结点；后继结点：该结点右端部分最左边下边的结点--》5.删除后自下而上进行平衡性的调整--》6.调整规则与插入时的4种调整完全椅子--》7.注意，删除结点后，AVL树的结果可能不唯一。

### B树(多路平衡查找树)B-Tree
#### B树的性质
1.m阶B树（每个结点最多有m个子树,最少是m/2）----除根结点外，结点关键字个数：m/2（上取整）-1 <= n <= m-1

2.每组结点内部关键字有序，左侧关键字<子树结点<右侧关键字

3.最下面存储关键字的结点为”终端结点“

4.最下面一层不存储关键字的结点为”叶子结点“，一般不画在B树中
![](./asset/1657020325355.jpg)
#### B树的插入
1.插入元素时一定插入在终端结点

2.插入位置通过查找元素大小进行确定

3.若插入后关键字个数超过上限，那么[m/2]作为中间元素将结点左右分为两个部分，中间元素上移作为父结点
![](./asset/1657021051786.jpg)
#### B树的删除
1.若被删除关键字在终端结点，可直接删除

2.若被删除的关键字没有在终端结点，可以用前驱关键字或者后继关键字替换该关键字，然后删除

3.若关键字个数低于下限，则向该结点的父结点借一个关键字

4.若兄弟结点关键字数量充足，则将兄弟结点的关键字借给父结点

5.若兄弟结点关键字数量不足，则合并该结点与兄弟结点

6.注意，删除关键字后，B树的结果可能不唯一

### B+树与B树的区别
1.B+树终端结点存储元素数据，分支结点不存储元素数据

2.B+树终端结点之间有指针直接相连，支持顺序查找
![](./asset/1657024323101.jpg)

应用在关系型数据库的索引
## 散列查找（哈希表）
1.哈希表的本质是通过运算，将高维度元素映射在低维度中进行存储

2.一般步骤：元素-》哈希函数-》哈希值-》冲突处理-》装入表中

3.装填因子=表中元素/总容量上限

4.计数排序可以帮助我们更好的理解哈希表

查找成功平均成功次数：（找内部已有的每个元素所需次数和/元素个数）

查找失败平均查找次数：%n，小于n的不同哈希值失败次数/n
![](./asset/1657018773905.jpg)

### 判断链表中是否有环
1.快慢指针法
2.哈希法（对结点指针进行哈希操作）
### 常见的哈希冲突处理方法
1.线性探测再散列法(往后找)

2.二次探测法（+1^2 \ -1^2 \ +2^2 \ -2^2 \ +3^2 \ -3^2 .....）

3.拉链法(链地址法)
![](./asset/1657018155342.jpg)

4.随机法



# 图
![1](./asset/1656419224055.jpg)
## 图的基本术语
### 1.节点，边（弧） 
### 2.有向边，无向边，有向图，无向图，完全图（从任意点到任意点都有边）；子图（从图中选出一些点和边）
### 3.度（与点相连的边的数量），入度（几条边以他为终点），出度（几条边以他为起点）
### 4.路径，回路（有向图）
### 5.连通图（无向图，从任意点到任意点都有路径），强连通图（有向图），连通分量（无向图，极大连通子图），强连通分量（有向图，....）
### 6.权值（边的权值），带权图。
## 图的存储
### 邻接矩阵
邻接矩阵是一个多维数组，存储节点间边的关系；设图的邻接矩阵为A，An的元素An[i][j]等于由顶点i到顶点j的长度为n的路径数目。
#### 存无向无权图
![2](./asset/1656462337345.jpg)
#### 存无向有权图
![3](./asset/1656462546697.jpg)
#### 有向图
![](./asset/1656462612358.jpg)
#### 邻接矩阵的优缺点
##### 优点
简单、直观，快速判断两点之间是否偶边
##### 缺点
浪费空间，不能快速访问与某点有关联的边，只能遍历
### 邻接表（链表）
邻接表存储了与每个节点有关的所有边与同一个节点有关的边都存到同一个链表。
#### 存无向图
![](./asset/1656463108478.jpg)
#### 存有向图
![](./asset/1656463163554.jpg)
#### 邻接表的优缺点
##### 优点
节省空间、快速访问与某点有关的边
##### 缺点
不直观、不能快速去判断某两点之间的关系 
## 图的遍历
### 深度优先遍历
从起点出发，每次走到一个新的点时就以新的点为起点继续向下走，当走到不能走时，再进行回溯，深度优先遍历一般使用递归实现。
![](./asset/1656548336023.jpg)
![](./asset/1656549056902.jpg)
### 广度优先遍历
 从起点出发，先遍历所有连通的点，接下来按照遍历的顺序，继续遍历每个点相连通的点，广度优先遍历一般使用队列实现
 ![](./asset/1656549408697.jpg)
 ![](./asset/1656550072785.jpg)
 ## 图的应用（算法）
 ### 最小生成树
 对于一个图来说，删掉一些边，使得每两个节点之间只有一条路径。那么，删掉边以后，可以等到一颗树，这棵树就叫做改图的生成树。所有生成树中，所有边权相加后，总权值最小的生成树，叫做最小生成树。
 ![](./asset/1656634760103.jpg)
 ![](./asset/1656634816027.jpg)
 #### 最小生成树的性质
 ##### 1.若图中有N个节点，那么生成树中应该有N-1条边
 ##### 2.最小生成树的权值总和唯一，但是最小生成树不一定唯一
 #### 最小生成树的求解方法
 ##### Prim算法(以点为基准)
 选择起点--》从所有向外部连接的边中，选择一条权值最短的--》将这条边所连接的点加入内部--》加入后，多了一些外部边，少了一些内部边--》继续这个过程，直到所有点均已连通
 ![](./asset/1656635421766.jpg)
 ##### Kruskal算法(以边为基准)
 并查集==》树形结构，查询两个点是否属于同一个集合（1.合并2.查询）
 ![](./asset/1656636862969.jpg)
 1.初始化并查集，将所有边按照权值排序--》2.按照权值从小到大，依次遍历所有的边--》3.遍历一条边时，判断这条边的两个端点是否相连（并查集）--》4.若相连，则这条边不是最小生成树中的一条边--》5.若不相连，则这条边是最小生成树中的一条边，连通这两点--》6.继续这个过程，直到所有点均已连通
 ![](./asset/1656672760929.jpg)
 ### 最短路径
 对于从节点A到节点B的所有路径，总权值最小的路径称之为从A到B的最短路径，简称最短路。最短路也不一定唯一，但是最短权值唯一。
 #### 最短路径的求解方法
 ##### 1.Dijkstra算法（单源最短路径）（不能有负权边）
 1.将所有点的答案改为无穷，确定起点，更新起点的答案为0--》2.在所有有答案且答案未被确定的点当中，选择答案最小的--》3.将该点的答案确定--》4.遍历以该点为起点的所有边，更新边终点的答案--》5.继续这个过程，直到所有点的答案均已确定
![](./asset/1656675638839.jpg)
 ##### 2.Floyd算法（多源最短路）
 for(i=1;i<=n>;i++)   -->i是中转点
    for(j=1;j<=n;j++)  -->j是起点
        for(k=1;k<=n;k++)  -->k是终点
            ans[j][k]=min(ans[j][k],ans[j][i]+ans[i][k])
### AOV网
用有向图表示一个工程，其节点表示活动。有向边1->5表示：1活动必须先于 5活动这样一种关系；则称这个图为AOV网（顶点表示活动的网络）
![](./asset/1656676999084.jpg)
#### 拓扑排序
对于AOV网来说，找到所有活动的一种排序，使得按照排序序列进行活动时，不违反网中活动先后顺序；在求解过程中通常使用入度计数来实现。（入度减1）
#### AOE网与关键路径
用有向图表示一个工程，其边表示活动，有向边1->5 的权值3表示该活动的开销（通常为活动所需时） 。
![](./asset/1656678689083.jpg)
关键路径：从源点到汇点的最长路径
![](./asset/1656678631761.jpg)
![](./asset/1656678952051.jpg)
# 总结
## 1.时间/空间复杂度
## 2.线性表 ==》顺序表，链表
## 3.栈，队列
## 4.树形结构，树，二叉树，森林
## 5.排序，插入，交换，选择，归并，基数
## 6.查找，顺序（二分），树型，哈希表
## 7.图，遍历，存储。。。。